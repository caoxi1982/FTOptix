// Copyright © 2022 Rockwell Automation, Inc. Generated on: 9/14/2022 12:18:31 PM Generated by: RA-INT\NHender
using Cca.Cgp.Common.Model;
using Cca.Cgp.Common.Model.ResponseStrategies;
using Cca.Cgp.Core.Base;
using Cca.Cgp.Core.Base.Extensions;
using Cca.Cgp.Core.Base.Ia;
using Cca.Cgp.Core.Base.Interfaces;
using Cca.Extensions.Common;
using Cca.Extensions.Common.DateTimeUtil;
using FTOptix.NetLogic;
using Newtonsoft.Json;
using Serilog;
using NetZero.EA.Strategies.Request;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading.Tasks;

using UAManagedCore;

using Log = UAManagedCore.Log;

namespace NetZero.EA
{
    public class FTOptixConcerto : Concerto
    {
        // static singleton instance of this concerto
        private static readonly FTOptixConcerto _instance = new();

        // logger for this class
        private static readonly ILogger s_Log = Serilog.Log.ForContext<FTOptixConcerto>();

        private bool _disposed;
        private bool _first;

        // response strategy for interacting with the model
        private ModelUpdatedResponseStrategy _modelResponseStrategy = null!;

        private NetLogicObject _netLogicObject = null;
        private readonly Dictionary<string, NodeId> _nodes = new();

        public new static FTOptixConcerto Instance => _instance;

        public NetLogicObject NetLogicObject
        {
            get => _netLogicObject;
            set => _netLogicObject = value;
        }

        /// <summary>
        /// Fired whenever there is a new model ready to use
        /// <para>
        /// If there are any actions to take upon recepit of a new model, the global static class
        /// GatewayModels contains the heirarchy and the global static class FqnLookup provides
        /// quick FQN/ID access to nodes
        /// </para>
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The (empty) <see cref="EventArgs"/> instance containing the event data.</param>
        public static void OnModelReceived(object sender, EventArgs e)
        {
            if (s_Log.IsEnabled(Serilog.Events.LogEventLevel.Debug))
            {
                s_Log.Debug("{method}", nameof(OnModelReceived));
            }
        }

        public void AddNodeId(string fqn, NodeId nodeid)
        {
            _nodes[fqn] = nodeid;
        }

        public override void ConcertoMain()
        {
            //Log.Info("ConcertoMain");
            if (_first)
            {
                _first = false;
                _mainTimer.Stop();
                _mainTimer.Dispose();
                _mainTimer = null;
                return;
                // perform any first-time initialization here
            }

            // keep track of how long since last transmit
            var stopWatch = Stopwatch.StartNew();
            // responses for this chunk
            var responseData = new ReactionData();
            // find requests that require a response
            try
            {
                DateTime thisLoopTimestamp = DateTime.Now;
                // has any app subscribed to any of our tags?
                if (!SubscribedTagsMap.IsEmpty)
                {
                    // loop through subscriptions
                    foreach (KeyValuePair<string, List<DataItemRequest>> tagRequestMaps in SubscribedTagsMap)
                    {
                        // get the id for this tag multiple apps can subscribe to the same tag and
                        // get the same value
                        string tagName = tagRequestMaps.Key;

                        // if the tagId is a guid
                        //if(Guid.TryParse(tagName, out var tagId))
                        //{
                        //}

                        if (TryGetNodeId(tagName, out NodeId nodeId))
                        {
                            string id = nodeId.Id.ToString();
                            Log.Info(nameof(FTOptixConcerto), $"ConcertoMain: {tagName} : {id}");
                            // see if we need to initialize the last time we sent an update for this tag
                            _ = _lastUpdates.TryAdd(tagName, DateTime.UtcNow.AddDays(-100).ToEpochMilliseconds());
                            // we need to determine the mime type for each tag here, we assume every
                            // value is a double precision floating point value see the
                            // MimeTypeExtensions class for standard mime type options
                            _ = _tagToMimeType.TryAdd(tagName, MimeTypeExtensions.DOUBLE_TAG_TYPE);
                            // did the timestamp for this tag change?
                            if (Cache.HasNewValue(id, _lastUpdates[tagName]))
                            {
                                Log.Info(nameof(FTOptixConcerto), $"ConcertoMain: {tagName} : new value");
                                // get latest VQT for this tag from our Cache if there is a
                                // different method for tracking values, then use that interface instead
                                var newVqt = Cache.GetLatestVqt(id);
                                // get previous Vqt transmitted for this subscription
                                var previousVqt = _tagLastValue[tagName];
                                // newest value
                                var newValue = newVqt.v;
                                // previously transmitted value
                                var oldValue = previousVqt?.v;
                                // did the value or quality change?
                                var changed = previousVqt == null || !newValue.Equals(oldValue) || newVqt.q != previousVqt.q;
                                // find all subscriptions to this tag
                                foreach (var request in tagRequestMaps.Value)
                                {
                                    // track the last transmit time for periodic subscriptions this
                                    // is done on a request-by-request basis since multiple apps
                                    // could subscribe to the same tag at different rates and with
                                    // different update types
                                    //
                                    // initialize with a very old last transmit time so that we
                                    // always send an initial value for a new subscriber we don't
                                    // care if this fails, as it only indicates that we already have
                                    // a last transmit time for the request
                                    _ = _tagLastTransmit.TryAdd(request.trackingId, DateTime.UtcNow.AddDays(-100));
                                    // how long since we last sent this value?
                                    var lastTransmitAge = (long)(thisLoopTimestamp - _tagLastTransmit[request.trackingId]).TotalMilliseconds;
                                    // default to OnChange
                                    var updateType = request.metadata.updateType ?? UpdateType.OnChange;
                                    // default to 1 second update
                                    var updateRateMs = request.metadata.updateRateMs ?? 1000;
                                    // determine if it is time to transmit a new value for this
                                    // request note that some clients might use OnPolling and other
                                    // clients might use OnChange for the same tag and each client
                                    // request might have different update rates
                                    var timeToTransmit =
                                            // has enough time elapsed since the last time we
                                            // transmitted a response to this request?
                                            lastTransmitAge >= updateRateMs &&
                                            (   // always send if polling
                                                updateType.Equals(UpdateType.Polling) ||
                                                // if onChange, only send if value/quality has changed
                                                updateType.Equals(UpdateType.OnChange) && changed
                                            );

                                    if (timeToTransmit)
                                    {
                                        // add to our Responses
                                        responseData.Add(request.GetResponseFromVqt(newVqt, _tagToMimeType[tagName]));
                                        // track last transmit by tracking id
                                        _tagLastTransmit[request.trackingId] = thisLoopTimestamp;
                                        // track last value transmitted
                                        _tagLastValue[tagName] = newVqt;
                                        Log.Info(nameof(FTOptixConcerto), $"ConcertoMain: {tagName} : sent new value");
                                    }
                                }
                            }
                        }
                    }
                    // if chunk size or chunk interval exceeded if chunk size or chunk interval
                    // exceeded chunkSizeIntervalMs and chunkIntervalSize are protected members of
                    // the base class with defaults of _chunkIntervalSize = 1000 action items or
                    // _chunkIntervalMs = 1000 ms
                    if (stopWatch.ElapsedMilliseconds >= _chunkIntervalMs ||
                            responseData.items.Count >= _chunkIntervalSize)
                    {
                        // send any new responses for this chunk/interval
                        QueueResponse(responseData);
                        // clear for the next loop
                        responseData = new ReactionData();
                        // reset stopWatch
                        stopWatch.Reset();
                        // start stopWatch
                        stopWatch.Start();
                    }
                }
                else
                {
                    //Log.Info("ConcertoMain: no subscribed tags");
                }
            }
            catch (Exception ex)
            {
                s_Log.Error(ex, "{id}: {ConcertoMain}", id, nameof(ConcertoMain));
            }
        }

        public override void RestartConcerto()
        {
            Log.Debug(nameof(FTOptixConcerto), $"RestartConcerto: enter");
            base.RestartConcerto();
            Log.Debug(nameof(FTOptixConcerto), $"RestartConcerto: exit");
        }

        public override void OnConsumeRequest(DataItemRequest[] requests)
        {
            foreach (var request in requests)
            {
                Log.Debug(nameof(FTOptixConcerto), $"OnConsumeRequest: {request.actionType}: {request.id}, {request.contextPrefix}, {request.contextUri}");
            }
            base.OnConsumeRequest(requests);
        }

        public override void OnConsumeResponse(DataItemResponse[] responses)
        {
            foreach (var response in responses)
            {
                Log.Debug(nameof(FTOptixConcerto), $"OnConsumeResponse: {response.reactionType}: {response.id}, {response.contextPrefix}, {response.contextUri}");
            }
            base.OnConsumeResponse(responses);
        }

        public override Task Start(IDictionary<string, object> options, ICgpComms audience, ICgpComms instrument, bool loadDefaultStrategies = true)
        {
            return base.Start(options, audience, instrument, loadDefaultStrategies);
        }

        /// <summary>
        /// initialize and start the concerto
        /// </summary>
        /// <param name="options"><see cref="Dictionary{string, object}"/> of startup parameters</param>
        /// <param name="audience"><see cref="ICgpComms"/> interface for requests</param>
        /// <param name="instrument"><see cref="ICgpComms"/> interface for responses</param>
        /// <returns></returns>
        public void FtoStart(IDictionary<string, object> options, ICgpComms audience, ICgpComms instrument)
        {
            AddRequestStrategy(new sm01(this));
            _modelResponseStrategy = new ModelUpdatedResponseStrategy(this);
            ModelUpdatedResponseStrategy.OnModelReceived += OnModelReceived;
            AddResponseStrategy(_modelResponseStrategy);
            Log.Info(nameof(FTOptixConcerto), "FtoStart - ReadLiveRequestStrategy");
            AddRequestStrategy(new ReadLiveRequestStrategy(this));
            Log.Info(nameof(FTOptixConcerto), "FtoStart - WriteLiveRequestStrategy");
            AddRequestStrategy(new WriteLiveRequestStrategy(this));

            Log.Info(nameof(FTOptixConcerto), "FtoStart - before StartInternal");
            base.StartInternal(options, audience, instrument, true).GetAwaiter().GetResult();
            Log.Info(nameof(FTOptixConcerto), "FtoStart - after StartInternal");
            _first = true;

            _mainTimer.Stop();
            _mainTimer.Dispose();
        }

        public IUAVariable GetVariableFromNodeId(NodeId nodeId)
        {
            if (NetLogicObject is { })
            {
                return NetLogicObject.Context.GetRootContext().GetRootContext().GetVariable(nodeId);
            }
            return null;
        }

        public new async Task Stop()
        {
            Log.Info("Stopping conenction to broker-addon");
            try
            {
                await base.Stop();
            }
            catch (Exception ex)
            {
                Log.Error(ex.Message);
            }

            await Task.CompletedTask;
            Log.Info("Connection to broker-addon stopped");
            return;
        }

        public static Node TryGetNodeFromNodeId(NodeId nodeId)
        {
            return FqnLookup.GetNodeFromId(nodeId.Id.ToString());
        }

        public bool TryGetNodeId(string fqn, out NodeId nodeId)
        {
            return _nodes.TryGetValue(fqn, out nodeId);
        }

        public void WriteModel(Node root, Node types)
        {
            Log.Info(nameof(FTOptixConcerto), "Sending model to broker-addon");
            ActionData actionData = new();
            actionData.Add("#model", ActionType.Write, "ctx://manager-svc").actionOptions = root;
            actionData.Add("#types", ActionType.Write, "ctx://model-svc").actionOptions = types;
            QueueRequest(actionData);
            Log.Info(nameof(FTOptixConcerto), "model sent");
        }

        protected override void Dispose(bool disposing)
        {
            if (_disposed)
            {
                return;
            }

            if (disposing)
            {
                // dispose of anything else that we own here
            }
            _disposed = true;

            // Call base class implementation.

            base.Dispose(disposing);
        }

        /// <summary>
        /// Simple async request to return the response of a request
        /// </summary>
        /// <param name="actionData"><see cref="ActionData"/> to request</param>
        /// <param name="timeoutMs">Fail after this many milliseconds, as <see cref="int"/></param>
        /// <returns><see cref="DataItemResponse"/> if success, else <see langword="null"/></returns>
        private new Task<DataItemResponse> GetResponseAsync(ActionData actionData, int timeoutMs = 5000) => GetResponseAsync(actionData, timeoutMs);

        /// <summary>
        /// Reads a tag's value by fqn, and returns the value as an <see langword="object"/>
        /// </summary>
        /// <param name="fqn">fqn of tag to write value to</param>
        /// <returns>vqts[0].v <see langword="object"/> or null if the request fails</returns>
        private async Task<object> ReadTagByFqn(string fqn)
        {
            var actionData = new ActionData();
            _ = actionData.Add(fqn, ActionType.Read, "fqn://manager-svc");
            var response = await GetResponseAsync(actionData);
            // is response not null and good quality?
            return response is { } && response.IsGood() ? response.vqts[0].v : null;
        }

        /// <summary>
        /// Reads a tag's value by id, and returns the value as an <see langword="object"/>
        /// </summary>
        /// <param name="id">id of tag to write value to</param>
        /// <returns>vqts[0].v <see langword="object"/> or null if the request fails</returns>
        private async Task<object> ReadTagById(string id)
        {
            var actionData = new ActionData();
            _ = actionData.Add(id, ActionType.Read, "id://manager-svc");
            var response = await GetResponseAsync(actionData);
            // is response not null and good quality?
            return response is { } && response.IsGood() ? response.vqts[0].v : null;
        }

        /// <summary>
        /// Writes a value to a tag by fqn and returns status
        /// </summary>
        /// <param name="fqn">fqn of tag to write value to</param>
        /// <param name="value">value to write to tag</param>
        /// <returns><see langword="true"/> if the write was successful</returns>
        private async Task<bool> WriteTagValueByFqn(string fqn, object value)
        {
            var actionData = new ActionData();
            var actionOptions = new Dictionary<string, object>()
            {
                {"v", value }
            };
            _ = actionData.Add(fqn,
                               ActionType.Write,
                               "fqn://manager-svc",
                               itemActionOptions: JsonConvert.SerializeObject(actionOptions));
            var response = await GetResponseAsync(actionData);
            return response is { } && response.IsGood();
        }

        /// <summary>
        /// Writes a value to a tag by id and returns status
        /// </summary>
        /// <param name="id">id of tag to write value to</param>
        /// <param name="value">value to write to tag</param>
        /// <returns><see langword="true"/> if the write was successful</returns>
        private async Task<bool> WriteTagValueById(string id, object value)
        {
            var actionData = new ActionData();
            var actionOptions = new Dictionary<string, object>()
            {
                {"v", value }
            };
            _ = actionData.Add(id,
                               ActionType.Write,
                               "id://manager-svc",
                               itemActionOptions: JsonConvert.SerializeObject(actionOptions));
            var response = await GetResponseAsync(actionData);
            return response is { } && response.IsGood();
        }
    }
}
