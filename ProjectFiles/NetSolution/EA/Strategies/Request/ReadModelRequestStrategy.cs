// Copyright © 2022 Rockwell Automation, Inc.
// Generated on: 9/16/2022 10:46:43 AM
// Generated by: RA-INT\NHender
//

using Cca.Cgp.Core.Base;
using Cca.Cgp.Core.Base.Extensions;
using Cca.Cgp.Core.Base.Ia;
using Cca.Cgp.Core.Base.Interfaces;
using Cca.Extensions.Common;
using Serilog;
using System;
using System.Collections.Generic;

namespace NetZero.EA.Strategies.Request
{
    public class ReadModelRequestStrategy : RequestStrategy
    {
        private static readonly ILogger s_Log = Log.ForContext<ReadModelRequestStrategy>();

        public ReadModelRequestStrategy(IRequestHandler requestHandler)
            : base(requestHandler)
        {
            // change priority according to your needs
            Priority = 30;
        }

        /// <summary>
        /// handles an individual request
        /// </summary>
        /// <param name="request"><see cref="DataItemRequest"/> to process</param>
        public override void HandleMessage(DataItemRequest request)
        {
            if (s_Log.IsEnabled(Serilog.Events.LogEventLevel.Debug))
            {
                s_Log.Debug("{id}: {rid}: {prefix}: {actionOptions}",
                            RequestHandler.Id,
                            request.id,
                            request.contextPrefix,
                            request.actionOptions);
            }

            // this handles messages one by one
            var vqt = Cache.ContainsID(request.id) ? Cache.GetLatestVqt(request.id) : null;
            if (vqt is { })
            {
                // send the last cached value
                RequestHandler.QueueResponse(request.GetReactionFromVqt(vqt, MimeTypeExtensions.DOUBLE_TAG_TYPE));
            }
            else
            {
                // send an error response
                RequestHandler.QueueResponse(request.GetErrorReaction($"No cached values for {request.id}"));
            }
        }

        /// <summary>
        /// accepts all incoming messages that are handled
        /// by this strategy, and then passes them
        /// one-by-one to the HandleMessage method
        /// </summary>
        /// <param name="requests"><see cref="IEnumerable{DataItemRequest}"/> to check</param>
        public override void HandleMessages(IEnumerable<DataItemRequest> requests)
        {
            // if group response processing is required, it can be done here
            // below is the base class implementation
            //foreach (var request in requests)
            //{
            //    HandleMessage(request);
            //}
            // use default handling
            base.HandleMessages(requests);
        }

        /// <summary>
        /// determines if this strategy should handled a given
        /// request based on the properties of the request object
        /// </summary>
        /// <param name="request"><see cref="DataItemRequest"/> to check</param>
        /// <returns>True if this strategy handles this request</returns>
        public override bool Handles(DataItemRequest request)
        {
            // do we have the necessary information to
            // process this request?
            if (request is null || string.IsNullOrEmpty(request.contextPrefix) || string.IsNullOrEmpty(request.id))
            {
                return false;
            }
            //
            // we should return true if this strategy handles this request
            return request.actionType.Equals(ActionType.Read) &&
                   request.contextPrefix.Equals("#LiveValues", StringComparison.OrdinalIgnoreCase);
        }
    }
}